\documentclass[12pt,a4paper]{article}
\usepackage{listings}
\usepackage{amssymb,amsmath,mathtools,amsthm}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[top=0.5in, bottom=0.75in, left=0.625in, right=0.625in]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{indentfirst}
\usepackage[colorlinks=true, urlcolor=magenta]{hyperref}
\usepackage{forest}
\newtheorem*{minimal_steps}{Утверждение}

\title{Алгоритмы и структуры данных, лекция 1}

\date{12.01.2016}

\author{}


\begin{document}
\maketitle

\section*{Оргмоменты}
Одна контрольная~--- контест на реализацию какого-то алгоритма. Пользоваться своим кодом запрещено.

Задача --- привести алгоритм, провести теоретический анализ (доказать его корректность, оценить время работы) и запрограммировать. Сначала сдаётся теория, потом практика.

Экзамен устный.

\[O_{\text{итоговая}} = 0.7 \cdot O_{\text{накопленная}}+0.3 \cdot O_{\text{экзамен}}\]
\[O_{\text{накопленная}} = 0.2 \cdot O_{\text{КР}} + 0.12 \sum\limits_{i = 1}^{5} O_{\text{ДЗ i}} + 0.2 \cdot O_{\text{семинары}}\]

Списывание, как обычно, \emph{не поощряется}. ДЗ предполагается не обсуждать.

\href{http://wiki.cs.hse.ru/}{Здесь} (ссылка слева) можно найти ссылки на ДЗ и краткое содержание лекций.

Автоматов \emph{пока} не предусмотрено.

\textbf{Литература:}
\begin{itemize}
    \item \href{https://yadi.sk/i/1enAa7YHmruFw}{Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К.~--- <<Алгоритмы. Построение и анализ>>}
    \item \href{https://yadi.sk/i/E_0-SVipmrvPz}{Дасгупта С., Пападимитриу Х., Вазирани У.~--- <<Алгоритмы>>}
\end{itemize}

\section*{Лекция}

\subsection*{Ханойские башни}
Есть три стержня. На первый стержень нанизано 64 диска, от самого большого к самому маленькому. Задача: переложить все диски на второй стержень. Ограничения:
\begin{itemize}
    \item Диски можно переносить только по одному.
    \item Нельзя класть диск большего диаметра на диск меньшего диаметра.
\end{itemize}

Какой может быть алгоритм?

Варианты из аудитории:
\begin{enumerate}
    \item Полный перебор
    \item Рекурсивный алгоритм.
\end{enumerate}

Рассмотрим такой рекурсивный алгоритм:
\begin{enumerate}
    \item Переложим все диски, кроме $n$-ного, на третий стержень;
    \item Переложим $n$-ный диск с первого на второй стержень;
    \item Переложим все остальные с третьего стержня на второй.
\end{enumerate}

\

Запишем этот алгоритм с помощью псевдокода:

\begin{algorithm}
\caption{Рекурсивный алгоритм решения задачи о Ханойской башне}
\begin{algorithmic}[1]
\Function{Hanoi3}{$n,i,j,k$}
\If{$n > 0$}
    \State \textsc{Hanoi3}($n-1,i,k,j$)
    \State move $i \to j$
    \State \textsc{Hanoi3}($n-1,k,j,i$)
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

Нарисуем дерево операций для $n = 3$:
\begin{center}
\begin{forest}
for tree={
    parent anchor=south,
    child anchor=north,
    if n children=0{
      font=\itshape,
      tier=terminal,
    }{},
  }
[{H(3,1,2,3)} [{H(2,1,3,2)} [{H(1,1,2,3)} [$1 \to 2$]]
                            [$1 \to 3$]
                            [{H(1,2,3,1)} [$2 \to 3$]]]
              [$1 \to 2$] 
              [{H(2,3,2,1)} [{H(1,3,1,2)} [$3 \to 1$]]
                            [$3 \to 2$]
                            [{H(1,1,2,3)} [$1 \to 2$]]]]
\end{forest}
\end{center}
Алогритм, по сути, обходит это дерево в глубину и при этом слева направо, выполняя все перемещения, что встретятся.

Это дерево можно рассматривать, как полное бинарное дерево глубины $n$, если перемещения учитывать не в отдельных листьях, а в родительских узлах. Тогда в каждом узле мы выполняем одно действие, а в полном бинарном дереве $2^n-1$ узлов. Следовательно, выполнняется $2^n-1$ перемещение.

Пусть число перемещений для $n$ дисков равно $f(n)$. Тогда верно следующее: \[f(n) = \begin{cases}0, &n=0\\2f(n-1)+1, &n>0\end{cases}\]
\textbf{Свойство:} \textit{$f(n) = 2^n - 1$}
\begin{proof} Докажем это по индукции. База верна, так как $f(0) = 0 = 2^0 - 1$. Теперь пусть предположение верно для $n - 1$, то есть $f(n - 1) = 2^{n - 1} - 1$. Тогда $f(n) = 2f(n - 1) + 1 = 2(2^{n - 1} - 1) + 1 = 2^n - 2 + 1 = 2^n - 1$, что и требовалось доказать. \end{proof}

Можно ли улучшить время работы? Оказывается, что нет.

Рассмотрим некоторый алгоритм. Он рано или поздно должен переложить наибольший диск на второй стержень. Для этого ничего не должно быть на нём и на втором, т.е. все на третьем. А как получить эту конфигурацию? Оптимальным алгоритмом на $n-1$ шаг, что приводит к нашим вычислениям и уже полученному минимальному результату в $2^n-1$.

\begin{minimal_steps}
Задачу о Ханойских башнях нельзя решить за меньшее число шагов, причём решение с таким числом шагов ровно одно.
\end{minimal_steps}
\begin{proof}
По индукции.
\begin{description}
\item[База $(n = 0)$:] очевидно, решить быстрее, чем за 0 шагов нельзя и последовательность такая ровно одна.

\item[Переход $(n - 1 \to n)$:] предположим, что мы доказали это утверждение для $n-1$. Рассмотрим утверждение для $n$. Рано или поздно алгоритму понадобится освободить первые два стержня, чтобы переложить первый диск на второй стержень. Необходимо сделать это одно перекладывание и после вернуть все оптимальным алгоритмом. Итого, опираясь на предположение индукции шагов в оптимальном и единственном решении для $n-1$, нам понадобится $2(2^{n-1} - 1) + 1$ шаг, что и равно $2^n -1$. \qedhere
\end{description}
\end{proof}

Изменим задачу:
\subsection*{Четыре стержня}
Условие в остальном ровно то же. 
Стала ли задача проще?

Сложнее она точно не стала, т.к. четвёртым можно просто не пользоваться.

Рассмотрев переход от двух к трём, кажется, что должно быть проще; как можно воспользоваться четвёртым?

Предложения:
\begin{itemize}
    \item Переложить предпоследний отдельно на четвёртый и сэкономить на перекладывании башни из $n-1$, перекладывая вместо неё башню из $n-2$
\end{itemize}


\begin{lstlisting}
Hanoi4(n,i,j,k,l)
    if n>0 then
        Hanoi4(n-2, i, k, j, l)
        move i to l
        move i to j
        move l to j
        Hanoi4(n-2, k, j, i, l)
\end{lstlisting}

Построив то же дерево, получим что в каждом узле три перемещения, а узлов $2^{\frac{n}2}-1$ --- экономия, но не очень большая.

Построим другой алгоритм:

\begin{lstlisting}
Hanoi4(n,i,j,k,l)
    if n>0 then
        Hanoi4(n-m, i, l, j, k)
        Hanoi3(n, i, j, k)
        Hanoi4(n-m, l, j, i, k)
\end{lstlisting}

Заметим, что число шагов зависит от $m$. Пусть $n=\frac{m(m+1)}{2}$ (если $n$ другое, то на первом шаге выберем такой $m$, чтобы $n-m$ было таким, а дальше на вход будет поступать число такого вида)

Получим то же двоичное дерево, но заметим, что число уровней в нём --- $m$, т.к. на каждом шаге $m$ уменьшается на 1 (ПОЧЕМУ? пояснить!), а в каждом узле работы проводится $2^m-1$, т.к. мы пользуемся уже доказанным алгоритмом для трёх стержней.

Сложим по уровням. На $i$-ом уровне сумма всех узлов --- $2^m-2^i$, при нумерации с нуля.

$g(n) = \begin{cases}
    0, m=0\\
    g(n_{m-1})+2^m=-1, m>0
\end{cases}$

$g(n) = \sum\limits_{i=0}^{m-1}(2^m-2^i) = m*2^m-\sum\limits_{i=0}^{m-1}2^i =
m*2^m-(2^m-1) = (m-1)\cdot2^m+1 $

Докажем по индукции:

База: $m=0; g(n_0) = 0 = -1\cdot2^0+1$

Переход: $g(m-1)=(m-2)\cdot2^{m-1}+1$
$g(m)=2((m-2)\cdot2^{m-1}+1)$ !!!!! СПИСАТЬ

$m\approx\sqrt{2n}; g(n)\approx\sqrt{2n}\cdot2^{\sqrt{2n}}$

$g(n) = \Theta(\sqrt{2n}\cdot2^{\sqrt{2n}})$


Попробуем обобщить этот алгоритм для любого числа стержней:

\begin{lstlisting}
Hanoi(n, i,j,P)
    if n>0 then
        choose p \in P 
        R := P\\\{p\}
        if R\neq\varnothong then
            Hanoi3(n, i, j, p)
        else
            Hanoi(n-m, i, p, R\cup\{j\})
            Hanoi(m, i, j, k)
            Hanoi(n-m, )<++>
\end{lstlisting}

$h(n_m, k) = \begin{cases}
    0, n=0\\
    2^{n_m}-1, n>0, k=3\\
    2h(n_{m-1}, k) + h(m, k-1), k>3
\end{cases}$

\end{document}
